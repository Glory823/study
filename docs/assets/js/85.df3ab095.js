(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{230:function(e,n,t){"use strict";t.r(n);var a=t(0),v=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"内置组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内置组件","aria-hidden":"true"}},[e._v("#")]),e._v(" 内置组件")]),e._v(" "),t("ol",[t("li",[e._v("transition 进入、离开列表过渡")])]),e._v(" "),t("h4",{attrs:{id:"过渡的类名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过渡的类名","aria-hidden":"true"}},[e._v("#")]),e._v(" 过渡的类名")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("v-enter")]),e._v("：定义进入过渡的==开始==状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("v-enter-active")]),e._v("：定义进入==过渡==生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("v-enter-to")]),e._v(": 定义进入过渡的==结束==状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("v-leave")]),e._v(": 定义离开过渡的==开始==状态。在离开过渡被触发时立刻生效，下一帧被移除。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("v-leave-active")]),e._v("：定义离开==过渡==生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("v-leave-to")]),e._v(": 定义离开过渡的==结束==状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<template>\n  <div id="app">\n      <transition>\n          <div class="box" v-show="flag">123</div>\n      </transition>\n  </div>\n</template>\n\n//css\n.v-enter,.v-leave-to{\n  opacity: 0;\n}\n.v-enter-active,.v-leave-active{\n  transition: all 3s;\n}\n.v-enter-to,.v-leave{\n   opacity: 1;\n}\n')])])]),t("p",[e._v("对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 transition，则 "),t("strong",[e._v("v- 是这些类名的默认前缀")]),e._v('。如果你使用了 transition name="my-transition"，那么 ==v-enter 会替换为 my-transition-enter==。')]),e._v(" "),t("h4",{attrs:{id:"自定义过渡类名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义过渡类名","aria-hidden":"true"}},[e._v("#")]),e._v(" 自定义过渡类名")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("enter-class")])]),e._v(" "),t("li",[t("p",[e._v("enter-active-class")])]),e._v(" "),t("li",[t("p",[e._v("enter-to-class")])]),e._v(" "),t("li",[t("p",[e._v("leave-class")])]),e._v(" "),t("li",[t("p",[e._v("leave-active-class")])]),e._v(" "),t("li",[t("p",[e._v("leave-to-class")])])]),e._v(" "),t("p",[e._v("他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<transition name="list" enter-active-class="animated rotateInDownLeft" leave-active-class="animated rotateOutDownLeft">\n    <div class="box" v-show="flag">123</div>\n</transition>\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("component 内置组件")])]),e._v(" "),t("p",[e._v("props")]),e._v(" "),t("ul",[t("li",[e._v("is - string | ComponentDefinition | ComponentConstructor")]),e._v(" "),t("li",[e._v("inline-template - boolean")])]),e._v(" "),t("p",[e._v('渲染一个"元组件"为动态组件。依 '),t("strong",[e._v("is")]),e._v(" 的值，来决定哪个组件被渲染。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --\x3e\n<component :is="componentId"></component>\n\n\x3c!-- 也能够渲染注册过的组件或 prop 传入的组件 --\x3e\n<component :is="$options.components.child"></component>\n')])])]),t("h4",{attrs:{id:"name"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#name","aria-hidden":"true"}},[e._v("#")]),e._v(" name")]),e._v(" "),t("p",[t("strong",[e._v("类型")]),e._v(":string")]),e._v(" "),t("p",[t("strong",[e._v("限制")]),e._v(":只有作为组件选项时起作用。")]),e._v(" "),t("p",[t("strong",[e._v("详细")]),e._v(": =="),t("strong",[t("em",[e._v("允许组件模板递归地调用自身")])]),e._v("==。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。")]),e._v(" "),t("p",[e._v("指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools，未命名组件将显示成 AnonymousComponent 标签，这很没有语义。通过提供 name 选项，可以获得更有语义信息的组件树。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//递归自身调用自身\n<template>\n   <ul>\n       <li v-for="(item,index) in lists" :key="index">\n           {{item.title}}\n           <detaile v-if="item.children" :lists="item.children"></detaile>//调用自己\n       </li>\n   </ul>\n</template>\n\n<script>\nexport default {\n    props:["lists"],\n    name:\'detaile\', //设置name属性,无需自己引入自己从而调用\n    components:{},\n    data(){\n        return {}\n    }\n}\n<\/script>\n')])])]),t("ol",{attrs:{start:"3"}},[t("li",[e._v("keep-alive 内置组件")])]),e._v(" "),t("ul",[t("li",[e._v("keep-alive 是 Vue.js 的一个内置组件。")]),e._v(" "),t("li",[e._v("keep-alive 包裹"),t("strong",[e._v("动态组件")]),e._v("时，==会缓存不活动的组件实例，而不是销毁它们。==")]),e._v(" "),t("li",[e._v("它自"),t("strong",[e._v("身不会渲染一个 DOM 元素")]),e._v("，"),t("strong",[e._v("也不会出现在父组件链中")]),e._v("。")]),e._v(" "),t("li",[e._v("当组件在 keep-alive 内被切换，它的"),t("strong",[e._v("activated")]),e._v("和 "),t("strong",[e._v("deactivated")]),e._v("这两个生命周期钩子函数将会被对应执行。")]),e._v(" "),t("li",[e._v("它提供了**"),t("em",[e._v("include")]),t("strong",[e._v("与")]),t("em",[e._v("exclude")]),e._v("**两个属性，允许组件有条件地进行缓存。")])]),e._v(" "),t("h6",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),t("p",[e._v("其实就是在 created 时将需要缓存的 VNode 节点保存在 this.cache 中／在 render 时,如果 VNode 的 name 符合在缓存条件（可以用 include 以及 exclude 控制），则会从 this.cache 中取出之前缓存的 VNode 实例进行渲染。")]),e._v(" "),t("h6",{attrs:{id:"用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用法","aria-hidden":"true"}},[e._v("#")]),e._v(" 用法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!-- 基本 --\x3e\n<keep-alive>\n  <component :is="view"></component>\n</keep-alive>\n//这里的component组件会被缓存起来。\n\x3c!-- 多个条件判断的子组件 --\x3e\n<keep-alive>\n  <comp-a v-if="a > 1"></comp-a>\n  <comp-b v-else></comp-b>\n</keep-alive>\n\n\x3c!-- 和 `<transition></transition>` 一起使用 --\x3e\n<transition>\n  <keep-alive>\n    <component :is="view"></component>\n  </keep-alive>\n</transition>\n')])])]),t("p",[t("strong",[e._v("注意")]),e._v(": keep-alive 标签是用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果"),t("strong",[e._v("有上述的多个条件性的子元素")]),e._v("，keep-alive "),t("strong",[e._v("要求同时只有一个子元素被渲染")]),e._v("。")]),e._v(" "),t("h6",{attrs:{id:"props"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#props","aria-hidden":"true"}},[e._v("#")]),e._v(" Props")]),e._v(" "),t("ul",[t("li",[e._v("include : 字符串或正则表达式。只有名称匹配的组件会被缓存。")]),e._v(" "),t("li",[e._v("exclude : 字符串或正则表达式。任何名称匹配的组件都不会被缓存。")]),e._v(" "),t("li",[e._v("max : 数字。最多可以缓存多少组件实例。")])]),e._v(" "),t("p",[e._v("include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!-- 逗号分隔字符串 --\x3e\n<keep-alive include="a,b">\n  <component :is="view"></component>\n</keep-alive>\n\n\x3c!-- 正则表达式 (使用 `v-bind`) --\x3e\n<keep-alive :include="/a|b/">\n  <component :is="view"></component>\n</keep-alive>\n\n\x3c!-- 数组 (使用 `v-bind`) --\x3e\n<keep-alive :include="[\'a\', \'b\']">\n  <component :is="view"></component>\n</keep-alive>\n')])])]),t("p",[t("strong",[e._v("匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//app.vue\n<template>\n  <div id="app">\n    <keep-alive include="home">//home要与每一个组件里面的name属性匹配\n      <component :is="componentId"></component>\n    </keep-alive>\n  </div>\n</template>\n\n//home.vue\nexport default {\n    props:[],\n    name:"home"//要与include或exclude里的内容匹配成功,才会实现缓存\n}\n')])])]),t("p",[e._v("max 最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<keep-alive :max="10">\n  <component :is="view"></component>\n</keep-alive>\n')])])])])}],!1,null,null,null);n.default=v.exports}}]);