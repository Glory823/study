(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{167:function(e,t,n){"use strict";n.r(t);var r=n(0),a=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"导航守卫"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#导航守卫","aria-hidden":"true"}},[e._v("#")]),e._v(" 导航守卫")]),e._v(" "),n("h4",{attrs:{id:"_1-组件内守卫"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-组件内守卫","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. 组件内守卫")]),e._v(" "),n("p",[e._v("在组件内才可以访问到")]),e._v(" "),n("pre",[n("code",[e._v("beforeRouterEnter(to,from,next){//获取不到this\n    //在渲染该组件的对应路由被config前调用\n    //因为当守卫执行前，组件实例还没有被创建\n    //to：到哪个路由去，from：从哪个路由来\n    调用next();\n},\nbeforeRouterUpdate(to,from,next){//可以访问到实例this\n    //在当前路由改变，但是该组件被复用是调用\n    调用next();\n},\nbeforeRouterLeave(to,from,next){//可以访问到实例this\n    //导航离开该组件的对应路由是调用\n}\n")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//在组件内使用 --\x3e 拦截该组件的跳转\nexport default {\n    data(){\n        return {\n            list:["first","second","third"]\n        }\n    },//组件内守卫\n    beforeRouteEnter (to, from, next) {\n        // console.log(to);//从哪里来\n        // console.log(from);//到哪里去\n        if(to.params.id >= 5){//判断条件\n            next("/");\n        }else{\n            next();\n        }\n    }\n}\n')])])]),n("h4",{attrs:{id:"_2-路由独享的守卫"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-路由独享的守卫","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. 路由独享的守卫")]),e._v(" "),n("p",[n("strong",[e._v("beforeEnter")])]),e._v(" "),n("p",[e._v("直接在路由配置项设置的,只有当前的路由可以访问到")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const router = new vueRouter({\n    routes: [{\n        path: "/",\n        name: "home",\n        component: home,\n        meta: { title: "首页" },\n        //路由独享守卫\n        beforeEnter: function(to, from, next) {\n            // console.log(to);\n            // console.log(from)\n            next()\n        }\n    }\n})\n')])])]),n("h4",{attrs:{id:"_3-全局守卫"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-全局守卫","aria-hidden":"true"}},[e._v("#")]),e._v(" 3. 全局守卫")]),e._v(" "),n("p",[e._v("守卫是==异步解析执行==的")]),e._v(" "),n("h6",{attrs:{id:"全局前置守卫"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全局前置守卫","aria-hidden":"true"}},[e._v("#")]),e._v(" 全局前置守卫")]),e._v(" "),n("p",[n("strong",[e._v("beforeEach")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//全局前置守卫 --\x3e可用于判断是否登录\n\nvar arr = ["/order", "/profile"];//需要做权限验证的路由\nrouter.beforeEach((to, from, next) => {\n    var flag = arr.includes(to.path);\n    if (flag) { //如果是这两个接口,跳转至登录接口\n        var useId = window.localStorage.getItem("useId");\n        if (useId) {\n            next();\n        } else {\n            next("/");\n        }\n    } else {\n        next();\n    }\n})\n')])])]),n("h6",{attrs:{id:"_3-1-全局后置守卫"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-全局后置守卫","aria-hidden":"true"}},[e._v("#")]),e._v(" 3.1 全局后置守卫")]),e._v(" "),n("p",[n("strong",[e._v("afterEach")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//全局后置守卫  --\x3e 可用于设置跳转每一个路由的标题\nrouter.afterEach((to, from, next) => {\n    if (to.meta && to.meta.title) {\n        document.title = to.meta.title;\n    }\n})\n")])])]),n("h4",{attrs:{id:"_3-2-守卫方法接受的参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-守卫方法接受的参数","aria-hidden":"true"}},[e._v("#")]),e._v(" 3.2 守卫方法接受的参数")]),e._v(" "),n("p",[e._v("1."),n("strong",[e._v("to")]),e._v(":Route: 即将要进入的目标 路由对象")]),e._v(" "),n("p",[e._v("2."),n("strong",[e._v("from")]),e._v(":Route: 当前导航正要离开的路由")]),e._v(" "),n("p",[e._v("3."),n("strong",[e._v("next")]),e._v(":Function.一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。")]),e._v(" "),n("pre",[n("code",[e._v("-next()：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。\n\n-next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。\n\n-next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。\n\n-next(error): 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调\n")])]),e._v(" "),n("h4",{attrs:{id:"_4-路由元信息"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-路由元信息","aria-hidden":"true"}},[e._v("#")]),e._v(" 4. 路由元信息")]),e._v(" "),n("p",[e._v("定义路由的时候可以配置==meta==字段")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const router = new vueRouter({\n    routes: [{\n        path: "/",\n        name: "home",\n        component: home,\n        meta: { title: "首页" }\n    }\n})\n')])])]),n("h4",{attrs:{id:"完整的导航解析流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#完整的导航解析流程","aria-hidden":"true"}},[e._v("#")]),e._v(" 完整的导航解析流程")]),e._v(" "),n("ol",[n("li",[e._v("导航被触发")]),e._v(" "),n("li",[e._v("在失活的组件里调用离开守卫")]),e._v(" "),n("li",[e._v("调用全局的beforeEach守卫")]),e._v(" "),n("li",[e._v("在重用的组件里调用beforeRouterUpdate")]),e._v(" "),n("li",[e._v("在路由配置里调用beforeEnter")]),e._v(" "),n("li",[e._v("解析异步路由组件")]),e._v(" "),n("li",[e._v("在被激活的组件里调用beforeRouterEnter")]),e._v(" "),n("li",[e._v("调用全局的被beforeResolve守卫")]),e._v(" "),n("li",[e._v("导航被确定")]),e._v(" "),n("li",[e._v("调用全局的afterEach钩子")]),e._v(" "),n("li",[e._v("触发DOM更新")]),e._v(" "),n("li",[e._v("用创建好的实例调用beforeRouterEnter守卫中传给next的回调函数")])])])}],!1,null,null,null);t.default=a.exports}}]);