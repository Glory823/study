(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{224:function(a,e,t){"use strict";t.r(e);var i=t(0),r=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"jsbridge"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jsbridge","aria-hidden":"true"}},[a._v("#")]),a._v(" JSBridge")]),a._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理","aria-hidden":"true"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),t("p",[a._v("关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/3/29/16270f34f02109eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"image"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/3/29/16270f45ca45db54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"image"}})]),a._v(" "),t("p",[a._v("移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上")]),a._v(" "),t("ul",[t("li",[a._v("基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案")]),a._v(" "),t("li",[a._v("非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native")])]),a._v(" "),t("p",[a._v("【注】:微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。")]),a._v(" "),t("h3",{attrs:{id:"jsbridge-的用途"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jsbridge-的用途","aria-hidden":"true"}},[a._v("#")]),a._v(" JSBridge 的用途")]),a._v(" "),t("p",[a._v("JSBridge 简单来讲，主要是 给 JavaScript 提供调用 Native 功能的接口，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。")]),a._v(" "),t("p",[a._v("JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/3/29/16270f744a3e61f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"image"}})]),a._v(" "),t("ul",[t("li",[a._v("JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。")]),a._v(" "),t("li",[a._v("Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。")])]),a._v(" "),t("ol",[t("li",[a._v("JavaScript 调用 Native")])]),a._v(" "),t("ul",[t("li",[a._v("注入 API\n原理:通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。")]),a._v(" "),t("li",[a._v("拦截 URL SCHEME\n原理:Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作")])]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[a._v("Native 调用 JavaScript\nNative 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。")])]),a._v(" "),t("h3",{attrs:{id:"通信原理小总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通信原理小总结","aria-hidden":"true"}},[a._v("#")]),a._v(" 通信原理小总结")]),a._v(" "),t("ul",[t("li",[a._v("JavaScript 调用 Native 推荐使用 注入 API 的方式")]),a._v(" "),t("li",[a._v("Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可")])]),a._v(" "),t("h3",{attrs:{id:"代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 代码实现")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("export default {\n  callbackIndex: 0,\n  callbackPrefix: '__MCL_CALLBACK_',\n  schema: 'chelunJSBridge',\n  invoke: function (namespace, api, param) {\n    namespace = String(namespace);\n    api = String(api);\n    var url = this.schema + '://' + namespace + '/' + api;\n    if (param && typeof param === 'object') {\n      url += this._buildQuery(param);\n    }\n\n    this._sendRequest(url);\n  },\n  _buildQuery: function (param) {\n    var seg = [], frag = '', uriSeg = '';\n    for (var attr in param) {\n      if (param.hasOwnProperty(attr)) {\n        if (param[attr] && typeof param[attr] === 'function') {\n          var callbackNo = this._createCallbackNo(param[attr]);\n          if (attr === 'callback') {\n            frag = '#' + callbackNo;\n          } else {\n            seg.push(encodeURIComponent(attr) + '=' + callbackNo);\n          }\n        } else {\n          var paramValue = String(param[attr]);\n          seg.push(encodeURIComponent(attr) + '=' + encodeURIComponent(paramValue));\n        }\n      }\n    }\n\n    seg.length && (uriSeg += '?' + seg.join('&'));\n    return uriSeg += frag;\n\n  },\n  //生成回调号\n  _createCallbackNo: function (fn) {\n    var callbackNo = this.callbackIndex;\n    window[this.callbackPrefix + callbackNo] = fn;\n    this.callbackIndex += 1;\n    return callbackNo;\n  },\n  //发送客户端调用请求\n  _sendRequest: function (uri) {\n    var i = document.createElement('iframe');\n    i.style.display = 'none';\n    i.onload = function () {\n      i.parentNode.removeChild(i);\n    };\n    i.src = uri;\n    document.body.appendChild(i);\n  }\n};\n\n")])])])])}],!1,null,null,null);e.default=r.exports}}]);